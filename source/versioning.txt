===================================
How to version your Python projects
===================================

Congratulations, you are about to release your first Python project to the
world, using the standard tool provided by Python: ``Distutils``.

This means that you have a ``setup.py`` file with something that can look
like this::

    from distutils.core import setup

    setup(name='MyProject', version='1.0', author='Tarek',
          author_email='tarek@ziade.org',
          url='http://example.com',)


And this gives you the power to register and upload your project to PyPI,
as simply as::

    $ python setup.py register sdist upload

Your project is then added in PyPI, among over 8000 other projects and
people can start using it, by downloading the archive you have created
with the ``sdist`` command.

With ``pip`` they can even install it with a simple command, ala ``apt-get``::

    $ pip install MyProject


Why you need version numbers ?
==============================

As soon as you start publishing your project to the world, you need to
version it. For example, the first version of your software can be ``1.0``.

Everytime you are releasing a new version with new features and bugfixes,
raising the version number will let your end users know that it is a
newer version. This is usally done by incrementing the version,
so your next version could be ``1.1``.

Once this new version is made available to the world on PyPI, people
will be able to install it, for example using ``pip``::

    $ pip install --upgrade MyProject

The ``upgrade`` option here means that Pip will look for all published
versions of ``MyProject`` on PyPI and see which one is the latest, then
upgrade your system to that version if you are not up-to-date.

Now imagine that you have introduced a small bug in ``1.1`` that makes
your project unusable on Windows. You are working on it, but you know
it will take you some time to resolve it.

The best strategy here is to tell you Windows user to stick with ``1.0``
until you have fixed the issue. They can downgrade to ``1.0`` because
it is still available on PyPI::

    $ pip install MyProject==1.0

This is possible because ``pip`` is able to sort the various versions
of your project, as long as it follows a standard version scheme.


Standard versioning schemes
===========================

The two most commone schemes used to version a software are **date-based**
schemes and **sequence-based** schemes.

Date scheme
-----------

Some projects use dates for the version numbers. That was the case for Wine
before it started using a sequence-based scheme. A date scheme is usually
using a ``YYYY-MM-DD`` form so versions can be sorted alphanumerically:

- 2009-08-10
- 2005-02-03
- etc.

This versioning scheme has a few limitations:

- you need to add hours to the scheme if you do more than one release
  per day.

- if you have maintenance branches over older releases, the overall
  order will not work anymore: a maintenance release of an older version
  will appear to be newer than a recent release.

Although, date schemes are commonly used as extra markers in versions schemes.

Sequence-based scheme
---------------------

The most common scheme is the sequence-based scheme, where each version is a
sequence of numerical values usually separated by dots (`.`):

- 1.0
- 1.1
- 1.0.1
- 1.3.4

This scheme removes the limitations we have seen with date-based schemes since
you can release maintenance versions and keep the proper order: versions are
ordered by comparing alphanumerically each segment of the version.

The most frequent sequence-based scheme is::

    MAJOR.MINOR[.MICRO]

where ``MAJOR`` designates a major revision number for the software, like ``2``
or ``3`` for Python. Usually, raising a major revision number means that you
are adding a lot of feature, breaking backward-compatibility or drastically
changing the APIs or ABIs.

``MINOR`` usually groups moderate changes to the software like bug fixes or
minor improvements. Most of the time, end users can upgrade with no risks
their software to a new minor release. In case an API changes, the end users
will be notified with deprecation warnings. In other words, API and ABI
stability is usually a promise between two minor releases.

Some softwares use a third level: ``MICRO``. This level is used when the
release cycle of minor release is quite long. In that case, micro releases
are dedicated to bug fixes.

Choosing between a major-based scheme and a micro-based one is really a
matter of taste. The most important thing is to document how your version
scheme works and what your end users should expect when you release a new
version. So be sure to define your release cycle properly before you
start releasing to the wild !

Development releases
::::::::::::::::::::

XXX

Pre-releases
::::::::::::

XXX

Post-releases
:::::::::::::

XXX

Defining your release cycle
===========================

A sofware usually follows this cycle:

- an internal development version is released, for testing purposes
- one or several pre-release are made for getting end-users feedback
  and avoiding releasing a `brown bag` release.
- a final version is released to the world, usually starting at
  ``1.0`` or ``0.1``.
- bugfixes and new features are added and new versions are released



XXX


Using a PEP 386 compatible scheme
=================================

XXX

Example
=======

XXX example of a setup.py with dev versions

Explains here how dev versions are automatically
numbered using the tip revision if --dev is used.


::

    from distutils.command.sdist import sdist
    import os

    class sdist_hg(sdist):

        user_options = sdist.user_options + [
                ('dev', None, "Add a dev marker")
                ]

        def initialize_options(self):
            sdist.initialize_options(self)
            self.dev = 0

        def run(self):
            if self.dev:
                suffix = '.dev%d' % self.get_tip_revision()
                self.distribution.metadata.version += suffix
            sdist.run(self)

        def get_tip_revision(self, path=os.getcwd()):
            from mercurial.hg import repository
            from mercurial.ui import ui
            from mercurial import node
            repo = repository(ui(), path)
            tip = repo.changelog.tip()
            return repo.changelog.rev(tip)

    setup(name='MyProject',
          version='1.0',
          packages=['package'],
          cmdclass={'sdist': sdist_hg})

