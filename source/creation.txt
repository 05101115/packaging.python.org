==================
Creating a Package
==================

Packaging with Distribute
=========================

Packages built and distributed using ``setuptools`` (a package provided by Distribute_) look to the user like ordinary Python packages based on the ``distutils``. Your users don’t need to install or even know about setuptools in order to use them, and you don’t have to include the entire ``setuptools`` package in your distributions. By including just a single bootstrap module (an 8K .py file), your package will automatically download and install ``setuptools`` if the user is building your package from source and doesn’t have a suitable version already installed.

Installation Instructions
-------------------------

Distribute is only released as a source distribution.

It can be installed using easy_install or pip, and can be done so with the source tarball, the eggs distribution, or by using the distribute_setup.py script provided online.

distribute_setup.py is the simplest and preferred way on all systems.

distribute_setup.py
Download distribute_setup.py and execute it, using the Python interpreter of your choice.

If your shell has the curl program you can do:

$ curl -O http://python-distribute.org/distribute_setup.py
$ python distribute_setup.py
Notice this file is also provided in the source release.

easy_install or pip
Run easy_install or pip:

$ easy_install -U distribute
$ pip install distribute
If you want to install the latest dev version, you can also run:

$ easy_install -U distribute==dev

Entry points
------------

Entry points are a Setuptools/Distribute feature that’s really handy in one
specific case: register something under a specific key in package A that
package B can query for.

Distribute itself uses it. If you’re packaging your project up properly, you’ve
probably used the ``console_scripts`` entry point::

    setup(name='zest.releaser',
          ...
          entry_points={
            'console_scripts':
                ['release = zest.releaser.release:main',
                 'prerelease = zest.releaser.prerelease:main',
                ]}
        )

``console_scripts`` is an entry point that Setuptools looks up. It looks up all
entry points registered under the name console_scripts and uses that
information to generate scripts. In the above example that’d be a bin/release
script that runs the main() method in zest/releaser/release.py.

You can use that for your own extension mechanism. For ``zest.releaser`` I
needed some extension mechanism. I wanted to be able to do extra things on
prerelease/release/postrelease time.

- Downloading an external javascript library into a package that cannot be
  stored in (zope’s) svn repository directly due to licensing issues. Before
  packaging and releasing it, that is. Automatically so you don’t forget it.

- Uploading a version.cfg to scp://somewhere/kgs/ourmainproduct-version.cfg
  after making a release to use it as a so-called “known good set” (KGS).

- Possibly modifying values (like a commit message) inside zest.releaser itself
  while doing a release. (I do get modification requests from time to time “hey,
  can you make x and y configurable”). So now every zest.releaser step
  (prerelease, release, postrelease) is splitted in two: a calculation phase
  and a “doing” phase. The results of the first phase are stored in a dict
  that gets used in the second phase. And you can register an entry point that
  gets passed that dict so you can modify it. See the entry point documentation
  of zest.releaser for details.

An entry point for zest.releaser is configured like this in your setup.py::

    entry_points={
        'console_scripts':
            ['myscript = my.package.scripts:main'],
        'zest.releaser.prereleaser.middle':
            ['dosomething = my.package.some:some_entrypoint, ]
    }

Replace prereleaser and middle in zest.releaser.prereleaser.middle with
prerelease/release/postrelease and before/middle/after where needed. (For this
specific zest.releaser example).

Now, how to use this in your program? The best way is to show a quick example
from zest.releaser where we query and use one of our entry points::

    import pkg_resources

    ...
    def run_entry_point(data):
        # Note: data is zest.releaser specific: we want to pass
        # something to the plugin group = 'zest.releaser.prerelease.middle'

        for entrypoint in pkg_resources.iter_entry_points(group=group):
            # Grab the function that is the actual plugin.
            plugin = entrypoint.load() # Call the plugin
            plugin(data)

So: pretty easy and simple way to allow other packages to register something
that you want to know. Extra plugins, extra render methods, extra functionality
you want to register in your web application, etcetera.

Packaging for a Particular Operating System (OS)
================================================

General Packaging Guidelines for Unix
-------------------------------------

General Packaging Guidelines for Windows
----------------------------------------
